-- Notice: Advoid using CamelCase for table names and column names in PostgreSQL, use snake_case instead.
-- Custom types
drop type if exists public.t_user_gender cascade;
create type public.t_user_gender as enum ('male', 'female', 'unknown');

drop type if exists public.t_menu_open_target cascade;
create type public.t_menu_open_target as enum ('external', 'internal', 'internalTab', 'internalTabPinned');

-- USERS
drop table if exists public.users cascade;
create table public.users (
  id            uuid references auth.users not null primary key, -- UUID from auth.users
  name          text,
  display_name  text,
  gender        t_user_gender default 'unknown'::public.t_user_gender,
  avatar        text,
  online        boolean default false,
  disabled      boolean default false,
  created_by    uuid references public.users,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_by    uuid references public.users,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);

-- ROLES
drop table if exists public.roles cascade;
create table public.roles (
  id            uuid NOT NULL DEFAULT uuid_generate_v4() primary key,
  name          text not null unique,
  display_name  text,
  remark        text,
  created_by    uuid references public.users not null,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_by    uuid references public.users not null,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);

-- MENUS
drop table if exists public.menus cascade;
create table public.menus (
  id            uuid NOT NULL DEFAULT uuid_generate_v4() primary key,
  name          text not null unique,
  display_name  text,
  url           text,
  icon          text,
  visible       boolean default true,
  keep_alive    boolean default false,
  target        t_menu_open_target default 'internalTab'::public.t_menu_open_target,
  parent_id     uuid references public.menus,
  created_by    uuid references public.users not null,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_by    uuid references public.users not null,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);

-- PERMISSIONS
drop table if exists public.permissions cascade;
create table public.permissions (
  id            uuid NOT NULL DEFAULT uuid_generate_v4() primary key,
  name          text not null unique,
  display_name  text,
  code          integer not null,
  remark        text,
  created_by    uuid references public.users not null,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_by    uuid references public.users not null,
  updated_at    timestamp with time zone default timezone('utc'::text, now()) not null
);

-- MENU PERMISSIONS
drop table if exists public.menu_permissions cascade;
create table public.menu_permissions (
  id              bigint generated by default as identity primary key,
  menu_id         uuid references public.menus on delete cascade not null,
  permission_id   uuid references public.permissions on delete cascade not null,
  created_by      uuid references public.users not null,
  created_at      timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (menu_id, permission_id)
);


-- USER ROLES
drop table if exists public.user_roles cascade;
create table public.user_roles (
  id          bigint generated by default as identity primary key,
  user_id     uuid references public.users on delete cascade not null,
  role_id     uuid references public.roles on delete cascade not null,
  created_by  uuid references public.users not null,
  created_at  timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (user_id, role_id)
);

-- ROLE PERMISSIONS
drop table if exists public.role_permissions cascade;
create table public.role_permissions (
  id            bigint generated by default as identity primary key,
  role_id       uuid references public.roles on delete cascade not null,
  permission_id uuid references public.permissions on delete cascade not null,
  created_by    uuid references public.users not null,
  created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (role_id, permission_id)
);

-- APP LOGS
drop table if exists public.logs cascade;
create table public.logs (
  id          bigint generated by default as identity primary key,
  user_id     uuid references public.users not null,
  session_id  uuid,
  ip          inet not null,
  user_agent  text,
  operation   text not null,
  level       text,
  meta        jsonb,
  created_at  timestamp with time zone default timezone('utc'::text, now()) not null
);


-- Check if the current user has the specified permission by name
drop function if exists public.fn_authorize(TEXT);
CREATE OR REPLACE FUNCTION public.fn_authorize(
  permission_name TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
  user_id UUID;
  permission_id UUID;
  has_permission BOOLEAN;
BEGIN
  -- Get the current user's ID
  user_id := auth.uid();

  -- Get the permission_id based on the permission_name
  SELECT p.id
  INTO permission_id
  FROM public.permissions p
  WHERE p.name = permission_name;

  -- If no matching permission_name is found, return false
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;

  -- Check if the user has the specified permission across any of their roles
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.role_permissions rp ON ur.role_id = rp.role_id
    WHERE ur.user_id = user_id
      AND rp.permission_id = permission_id
  ) INTO has_permission;

  RETURN has_permission;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER SET search_path = public;

-- Assert that the user has the specified role
create or replace function public.fn_assert_role(
  user_id uuid,
  role_id uuid
)
returns boolean as $$
declare
  has_role boolean;
begin
  -- Check if the user has the specified role
  select exists (
    select 1
    from public.user_roles ur
    where ur.user_id = user_id and ur.role_id = role_id
  ) into has_role;
  
  return has_role;
end;
$$ language plpgsql security definer set search_path = public;

-- Secure the tables
alter table public.users enable row level security;
alter table public.roles enable row level security;
alter table public.menus enable row level security;
alter table public.permissions enable row level security;
alter table public.menu_permissions enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;
alter table public.logs enable row level security;

create policy "Allow logged-in read access" on public.users for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.users for insert with check ( auth.uid() = id );
create policy "Allow individual update access" on public.users for update using ( auth.uid() = id );

create policy "Allow logged-in read access" on public.roles for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.roles for insert with check ( auth.uid() = created_by );
create policy "Allow individual update access" on public.roles for update using ( auth.uid() = created_by );
create policy "Allow individual delete access" on public.roles for delete using ( auth.uid() = created_by );
create policy "Allow authorized delete access" on public.roles for delete using ( fn_authorize('roles.delete') );

create policy "Allow logged-in read access" on public.menus for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.menus for insert with check ( auth.uid() = created_by );
create policy "Allow individual update access" on public.menus for update using ( auth.uid() = created_by );
create policy "Allow individual delete access" on public.menus for delete using ( auth.uid() = created_by );
create policy "Allow authorized delete access" on public.menus for delete using ( fn_authorize('menus.delete') );

create policy "Allow logged-in read access" on public.permissions for select using ( auth.role() = 'authenticated' );
create policy "Allow individual insert access" on public.permissions for insert with check ( auth.uid() = created_by );
create policy "Allow individual update access" on public.permissions for update using ( auth.uid() = created_by );
create policy "Allow individual delete access" on public.permissions for delete using ( auth.uid() = created_by );
create policy "Allow authorized delete access" on public.permissions for delete using ( fn_authorize('permissions.delete') );

create policy "Allow individual read access" on public.menu_permissions for select using ( auth.uid() = created_by );
create policy "Allow authorized read access" on public.menu_permissions for select using ( fn_authorize('menu_permissions.select') );

create policy "Allow individual read access" on public.user_roles for select using ( auth.uid() = user_id );
create policy "Allow authorized read access" on public.user_roles for select using ( fn_authorize('user_roles.select') );


create policy "Allow individual read access" on public.role_permissions for select using ( fn_assert_role(auth.uid(), role_id) );
create policy "Allow authorized read access" on public.role_permissions for select using ( fn_authorize('role_permissions.select') );

create policy "Allow individual read access" on public.logs for select using ( auth.uid() = user_id );
create policy "Allow individual insert access" on public.logs for insert with check ( auth.uid() = user_id );
create policy "Allow authorized read access" on public.logs for select using ( fn_authorize('logs.select') );

-- Send "previous data" on change 
alter table public.users replica identity full; 
alter table public.roles replica identity full; 
alter table public.menus replica identity full;
alter table public.permissions replica identity full;

/**
 * REALTIME SUBSCRIPTIONS
 * Only allow realtime listening on public tables.
 */

begin; 
  -- remove the realtime publication
  drop publication if exists supabase_realtime; 

  -- re-create the publication but don't enable it for any tables
  create publication supabase_realtime;  
commit;

-- add tables to the publication
alter publication supabase_realtime add table public.users;
alter publication supabase_realtime add table public.roles;
alter publication supabase_realtime add table public.menus;
alter publication supabase_realtime add table public.permissions;

/**
 * AUTH HOOKS
 * Create an auth hook to add a custom claim to the access token jwt.
 */

-- Create the auth hook function
-- https://supabase.com/docs/guides/auth/auth-hooks#hook-custom-access-token
create or replace function public.fn_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
declare
  claims jsonb;
  u_roles text[];
  user_id uuid;
  permissions jsonb;
  menu_permissions jsonb;
begin
  -- Extract user_id from the event
  user_id := (event->>'user_id')::uuid;

  -- Get the user's roles
  select array_agg(r.name)
  into u_roles
  from public.user_roles ur
  join public.roles r on ur.role_id = r.id
  where ur.user_id = user_id;

  claims := event->'claims';

  -- If the user has roles, set the roles array in the claims
  if u_roles is not null then
    claims := jsonb_set(claims, '{roles}', to_jsonb(u_roles));
  else
    -- If the user has no roles, set user_roles to null
    claims := jsonb_set(claims, '{roles}', 'null');
  end if;

  -- Get the list of permissions for the user
  select jsonb_agg(p.name)
  into permissions
  from public.permissions p
  join public.role_permissions rp on p.id = rp.permission_id
  join public.user_roles ur on rp.role_id = ur.role_id
  where ur.user_id = user_id;

  -- Get the list of menu permissions for the user
  select jsonb_object_agg(mp.menu_id, sum(p.code))
  into menu_permissions
  from public.permissions p
  join public.role_permissions rp on p.id = rp.permission_id
  join public.user_roles ur on rp.role_id = ur.role_id
  join public.menu_permissions mp on p.id = mp.permission_id
  where ur.user_id = user_id
  group by mp.menu_id;

  -- Add permissions and menu_permissions to claims
  claims := claims || jsonb_build_object(
    'permissions', permissions,
    'menu_permissions', menu_permissions
  );

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Return the modified or original event
  return event;
end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.fn_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.fn_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)
